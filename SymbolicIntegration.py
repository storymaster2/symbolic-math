from SymbolicMath import Coefficient
from SymbolicMath import Symbol
from SymbolicMath import SymbolSet
from SymbolicMath import PolynomialExpression
from SymbolicMath import PolynomialSeries
from SymbolicMath import SymbolicMatrix
import time

# Euclidian Polynomial Division
def PolyDivide(A,B):
    # Given a field K
    # Given A, B are elements of K[x] (translation: A and B are polynomials)
    # Given B != 0
    # Return Q, E elements of K[x] such that A = BQ + R and either R = 0 or deg(R) < deg(B)
    # Q is the quotient of A by B
    # R is the remainder of A by B

    if not(isinstance(A, PolynomialExpression), isinstance(B, PolynomialExpression)):
        raise Exception("inputs aren't PolynomialExpressions")

    if B == 0:
        raise Exception("Divide by zero error: B cannot be zero")

    Q = PolynomialExpression(0,0)
    R = A
    d = R.degree - B.degree
    while R != 0 and (d >= 0):
        T = PolynomialExpression(R.lc/B.lc,d)
        Q += T
        R -= B * T
        d = R.degree - B.degree

    return([Q,R])

# Euclidian Polynomial Pseudo-Division
def PolyPseudoDivide(A,B):
    # Given an integral domain D
    # Given A, B are elements of D[x]
    # Given B != 0
    # Return pseudoQuotient, pseudoRemainder elements of D[x]
    # Note: the potential advantage of this function over PolyDivide is that it can operate on integers and return integer results.
    # Could be useful for expressing results in fractions of integers rather than floats

    if not(isinstance(A, PolynomialExpression), isinstance(B, PolynomialExpression)):
        raise Exception("inputs aren't PolynomialExpressions")

    if B == 0:
        raise Exception("Divide by zero error: B cannot be zero")
    
    b = B.lc
    N = A.degree - B.degree + 1
    Q = PolynomialExpression(0,0)
    R = A
    d = R.degree - B.degree
    while R != 0 and (d >= 0):
        T = PolynomialExpression(R.lc,d)
        N -= 1
        Q = Q * b + T
        R = R * b - B * T
        d = R.degree - B.degree
    
    return [Q, R]

# Euclidian algorithm for computing greatest common divisor (gcd) of a and b
def Euclidian(a,b):
    # Given a Euclidian domain D
    # Given a, b are elements of D
    # Return the greatest common divisor (gcd) of a and b

    if not(isinstance(a, PolynomialExpression), isinstance(b, PolynomialExpression)):
        raise Exception("inputs aren't PolynomialExpressions")

    while b != 0:
        remainder = a % b
        a = b
        b = remainder
    
    return a

# Half Extended Euclidian algorithm
def HalfExtendedEuclidian(a, b, c = None):

    if not(isinstance(a, PolynomialExpression), isinstance(b, PolynomialExpression)):
        raise Exception("inputs aren't PolynomialExpressions")

    if c == None:
        # Basic (2 parameter) version of the algorithm
        # Given a Euclidian domain D
        # Given a, b are elements of D
        # Return s, g, elements of D, such that g = gcd(a,b) and sa = g(mod b)

        a1 = PolynomialExpression(1,0)
        b1 = PolynomialExpression(0,0)

        while b != 0:
            quotient = a // b
            remainder = a % b
            a = b
            b = remainder
            temp = a1 - quotient * b1
            a1 = b1
            b1 = temp
    
        return [a1, a]
    else:
        # Diophantine (3 parameter) version of the algorithm
        # Given a Euclidian domain D
        # Given a, b, c are elements of D
        # Given c is a member of the ideal generated by (a,b)
        # Return s, element of D, such that sa = c(mod b) and either s = 0 or the degree of s is less than the degree of b

        if not(isinstance(c, PolynomialExpression)):
            raise Exception("inputs aren't PolynomialExpressions")
        
        S_G = HalfExtendedEuclidian(a,b)
        s = S_G[0]
        g = S_G[1]
        q = c // g
        r = c % g
        if r == 0:
            s *= q
            if s != 0 and s.degree >= b.degree:
                s = s % b
            return s
        else:
            raise Exception("c is not in the ideal generated by a and b")

# Extended Euclidian algorithm
def ExtendedEuclidian(a, b, c = None):

    if c == None:
        # Basic (2 parameter) version of the algorithm
        # Given a Euclidian domain D
        # Given a, b are elements of D
        # Return s, t, and g, elements of D, such that g = gcd(a,b) and sa + tb = g

        S_G = HalfExtendedEuclidian(a,b)
        s = S_G[0]
        g = S_G[1]
        t = (g - s * a) // b
        return [s, t, g]
    
    else:
        # Diophantine (3 parameter) version of the algorithm
        # Given a Euclidian domain D
        # Given a, b, c are elements of D
        # Given c is a member of the ideal generated by (a,b)
        # Return s and t, elements of D, such that sa + tb = c and either s = 0 or the degree of s is less than the degree of b

        s = HalfExtendedEuclidian(a,b,c)
        t = (c - s * a) // b
        return [s, t]

# Partial Fraction Decomposition
def PartialFraction(a, dList, eList=None):

    if eList == None:
        # Basic version of the algorithm
        # Given a Euclidian domain D
        # Given a list of length n
        # Given a, d1, d2,...,dn are nonzero elements of D with gcd(di, dj) = 1 when i != j
        # Return a0, a1,...,an, elements of D, such that a divided by the product of all the ds = a0 plus the sum from 1 to n of ai/di
        # and either ai = - or the degree of a1 is less than the degree of di for i >= 1

        productOf_dList = PolynomialExpression(1,0)
        for d in dList:
            productOf_dList *= d

        result_a0_r = PolyDivide(a, productOf_dList)
        if len(dList) == 1:
            return result_a0_r
        else:
            a0 = result_a0_r[0]
            r = result_a0_r[1]
            d1 = dList.pop(0)
            productOf_dList = PolynomialExpression(1,0)
            for d in dList:
                productOf_dList *= d
            
            result_a1_t = ExtendedEuclidian(productOf_dList, d1, r)
            a1 = result_a1_t[0]
            t = result_a1_t[1]
            recursionResults = PartialFraction(t,dList)

            returnResults = []
            returnResults.append(a0 + recursionResults.pop(0))
            returnResults.append(a1)
            returnResults.extend(recursionResults)
            return returnResults
    
    else:
        # Complete version of the algorithm
        
        expandedFactors = []
        for i in range(len(dList)):
            expandedFactors.append(dList[i] ** eList[i])

        aList = PartialFraction(a, expandedFactors)
        a0 = aList.pop(0)
        aReturnList = []
        for i in range(len(dList)):
            for j in range(eList[i], 0, -1):
                aReturnList.append(aList[i] % dList[i])
                aList[i] = aList[i] // dList[i]
            a0 += aList[i]
        returnList = [a0]
        returnList.extend(aReturnList)
        return returnList

def createSylvesterMatrix(A, B):
    m = B.degree
    n = A.degree
    size = m + n

    sylvesterMatrix = SymbolicMatrix(rowCount = size, columnCount= size)

    for i in range(m):
        row = []
        for j in range(i):
            row.append(0)
        coeff_A = A.getCoefficientList()
        row.extend(coeff_A)
        for j in range(size - n - 1 - i):
            row.append(0)
        sylvesterMatrix[i] = row
    
    for i in range(n):
        row = []
        for j in range(i):
            row.append(0)
        coeff_B = B.getCoefficientList()
        row.extend(coeff_B)
        for j in range(size - m - 1 - i):
            row.append(0)
        sylvesterMatrix[m + i] = row

    return sylvesterMatrix

def resultant(A, B, i = None):
    if not(i == None):
        coefficients = []
        exponents = []
        for n in range(i+1):
            coefficients.append(SylvesterSubmatrix(A,B,i,n).det())
            exponents.append(n)
        return PolynomialExpression(coefficients, exponents)
    else:
        return createSylvesterMatrix(A,B).det()

def SylvesterSubmatrix(A, B, j, i = None):
    m = B.degree
    n = A.degree
    S = createSylvesterMatrix(A, B)
    deleteRows = []
    deleteRows.extend(range(m - j, m, 1))
    deleteRows.extend(range(m + n - j, m + n, 1))
    S.deleteRows(deleteRows)

    if not(i == None):
        deleteColumns = [*range(m + n - 2*j - 1, m + n, 1)]
        deleteColumns.remove(m + n - i - j - 1)
        S.deleteColumns(deleteColumns)

    return S

# Subresultant algorithm
def SubResultant(A, B):
    # Given an integral domain D
    # Given A, B are elements of D
    # Given B != 0
    # Given degree of A >= degree of B
    # Return the resultant of (A,B) and the subresultant Partial Remainder Sequence (PRS)

    if not(isinstance(A, PolynomialExpression), isinstance(B, PolynomialExpression)):
        raise Exception("inputs aren't PolynomialExpressions")

    if B == 0:
        raise Exception("B cannot be zero")

    R = [A,B]
    i = 1
    y = [0,-1]
    d = [0,A.degree - B.degree]
    Beta = [0,(-1) ** (d[1] + 1)]
    r = [R[0].lc]

    while R[i] != 0:
        r.append(R[i].lc)
        remainder = PolyPseudoDivide(R[i-1], R[i])[1]
        R.append((remainder / Beta[i]).simplify())
        i += 1
        y.append(((-1 * r[i-1]) ** d[i-1]) * (y[i-1] ** (1-d[i-1])))
        d.append(R[i-1].degree - R[i].degree)
        Beta.append(-1 * r[i-1] * (y[i] ** d[i]))
    
    k = i - 1

    if R[k].degree > 0:
        resultant = 0
        returnList = [resultant]
        returnList.extend(R)
        return returnList
    if R[k - 1].degree == 0:
        resultant = R[k].getCoefficientList()[0]
        returnList = [resultant]
        returnList.extend(R)
        return returnList
    else:
        s = 1
        c = 1
        for j in range(1, k+1):
            if R[j-1].degree % 2 == 1 and R[j].degree % 2 == 1:
                s *= -1
                c *= ((B[j] / (r[j] ** (1+d[j]))) ** R[j].degree) * (r[j] ** (R[j-1].degree - R[j+1].degree))

        resultant = ((R[k] ** R[k-1].degree) * s * c).getCoefficientList()[0]
        returnList = [resultant]
        # returnList.append(PolynomialSeries(R))
        returnList.extend(R)
        return returnList

def gcd2(a,b):
    if isinstance(a, PolynomialExpression):
        if not(isinstance(b, PolynomialExpression)):
                raise Exception("inconsistent arguments: arguments shall all be of the same type")
        polynomialGCD = Euclidian(a, b)
        return polynomialGCD / content(polynomialGCD)
    else:
        while not(a == 0):
            temp = a
            a = b % a
            if a == temp:
                return 1
            b = temp
        return b

# Greatest Common Divisor algorithm
def gcd(*args):
    input = []
    for element in args:
        if (isinstance(element, list)):
            input.extend(element)
        else:
            input.append(element)

    result = input[0]
    for n in input[1:]:
        result = gcd2(n, result)
    return result

def content(A):
    if not(isinstance(A, PolynomialExpression)):
        raise Exception("input A must be a polynomial")

    coefficients = [i for i in A.getCoefficientList() if i != 0]
    return gcd(coefficients)

def primitivePart(A):
    if not(isinstance(A, PolynomialExpression)):
        raise Exception("input A must be a polynomial")
    
    return A / content(A)

# Musser's squarefree factorization
def Squarefree_Musser(A):
    # Given a unique factorization domain D of characteristic 0
    # Given A is an element of D[x]
    # Return A1,...,Am, elements of D[x] such that the sum product of A_k^k from k=1 to m = A and is a squarefree factorization of A

    if not(isinstance(A, PolynomialExpression)):
        raise Exception("input A must be a PolynomialExpression")

    c = content(A)
    S = primitivePart(A)
    S_deflation = gcd(S, S.getDerivative())
    S_squarefree = PolyDivide(S, S_deflation)[0]
    k = 1
    A = []

    while S_deflation.degree > 0:
        Y = gcd(S_squarefree, S_deflation)
        A.append(S_squarefree // Y)
        S_squarefree = Y
        S_deflation = S_deflation // Y
        k += 1
    
    A.append(S_squarefree)
    multiplier = S_deflation * c
    factors = []
    
    for i in range(len(A)):
        factor = A[i] * multiplier
        for n in range(i+1):
            factors.append(factor)

    return factors

# Yun's squarefree factorization
def Squarefree(A, separateConstant=False):
    # Given a unique factorization domain D of characteristic 0
    # Given A is an element of D[x]
    # Return A1,...,Am, elements of D[x] such that the sum product of A_k^k from k=1 to m = A and is a squarefree factorization of A

    if not(isinstance(A, PolynomialExpression)):
        raise Exception("input A must be a PolynomialExpression")

    c = content(A)
    S = primitivePart(A)
    S_prime = S.getDerivative()
    S_deflation = gcd(S, S_prime)
    S_squarefree = S // S_deflation
    Y = S_prime // S_deflation
    k = 1
    Z = Y - S_squarefree.getDerivative()
    A = []

    while not(Z.isZero()):
        A.append(gcd(S_squarefree, Z))
        S_squarefree = S_squarefree // A[k-1]
        Y = Z // A[k-1]
        k += 1
        Z = Y - S_squarefree.getDerivative()
    
    A.append(S_squarefree)
    factors = []

    for i in range(len(A)):
        if separateConstant:
            factors.append(A[i])
        else:
            factors.append(A[i] * c)

    if separateConstant:
        return [c, factors]
    else:
        return factors

# Hermite Reduction - original version
def HermiteReduce_original(A, D):
    # Given a field K
    # Given A, D are elements of K[x]
    # Given D is nonzero and coprime with A
    # Return g,h elements of K[x] such that A/D = g' + h (g' is the derivative of g), and h has a squarefree denominator

    if not(isinstance(A, PolynomialExpression), isinstance(D, PolynomialExpression)):
        raise Exception("inputs aren't PolynomialExpressions")

    if D.isZero():
        raise Exception("D cannot be zero")

    if D.isZero(): #TODO: this is a placeholder - find a way to check if A and D are coprime
        raise Exception("D must becoprime with A")

    D_squarefreeFactorization = Squarefree(D)
    D_factors = []
    for i in range(len(D_squarefreeFactorization)):
        D_factors.append(D_squarefreeFactorization[i] ** (i+1))
    PFD = PartialFraction(A, D_factors.copy())
    P = PFD.pop(0)
    g = PolynomialExpression(0)
    h = P + PFD[0] / D_squarefreeFactorization[0]
    k = 1

    while k < len(D_factors) and D_factors[k].degree > 0:
        V = D_squarefreeFactorization[k]
        for j in range(k,0,-1):
            B_C = ExtendedEuclidian(V.getDerivative(), V, PFD[k] / (-1 * j))
            B = B_C[0]
            C = B_C[1]
            g = g + B / (V ** j)
            PFD[k] = C * (-1 * j) - B.getDerivative()

        h += PFD[k] / V
        k += 1

    return [g.simplify(),h.simplify()]

# Hermite Reduction - quadratic version
def HermiteReduce_quadratic(A, D):
    # Given a field K
    # Given A, D are elements of K[x]
    # Given D is nonzero and coprime with A
    # Return g,h elements of K[x] such that A/D = g' + h (g' is the derivative of g), and h has a squarefree denominator

    D_factors = Squarefree(D)
    g = PolynomialExpression(0)
    i = 1

    while i < len(D_factors) and D_factors[i].degree > 0:
        V = D_factors[i]
        U = PolyDivide(D,V.raiseToPower(i+1))[0]
        for j in range(i,0,-1):
            B_C = ExtendedEuclidian(U * V.getDerivative(), V, A / (-1 * j))
            B = B_C[0]
            C = B_C[1]
            g = g + B / (V ** j)
            A = C * (-1 * j) - U * B.getDerivative()
        D = U * V
        i += 1
    
    return [g.simplify(), (A / D).simplify()]

# Hermite Reduction - Mack's linear version
def HermiteReduce(A, D):
    # Given a field K
    # Given A, D are elements of K[x]
    # Given D is nonzero and coprime with A
    # Given D is primitive (TODO: check what this means)
    # Return g,h elements of K[x] such that A/D = g' + h (g' is the derivative of g), and h has a squarefree denominator

    g = PolynomialExpression(0)
    D_deflated = gcd(D,D.getDerivative())
    D_squarefree = D / D_deflated
    while D_deflated.degree > 0:
        D_deflated_2 = gcd(D_deflated, D_deflated.getDerivative())
        D_deflated_squarefree = D_deflated / D_deflated_2
        B_C = ExtendedEuclidian((D_squarefree * -1 * D_deflated.getDerivative()) / D_deflated, D_deflated_squarefree, A)
        B = B_C[0]
        C = B_C[1]
        A = C - B.getDerivative() * D_squarefree / D_deflated_squarefree
        g = g + B / D_deflated
        D_deflated = D_deflated_2
    
    return [g.simplify(), (A / D_squarefree).simplify()]

def deflate(D):
    # returns the deflated polynomial
    return gcd(D,D.getDerivative())

def simpleSquarefree(D):
    # returns the squarefree version of the polynomial (TODO: check this is the proper term. The book uses D* for this)
    return D // deflate(D)

# Horowitz-Ostrogradsky algorithm
def HorowitzOstrogradsky(A, D):
    # Given a field K
    # Given A, D are elements of K[x]
    # Given degree of A is less than degree of B
    # Given D is nonzero and coprime with A
    # Return g,h elements of K[x] such that A/D = g' + h (g' is the derivative of g), and h has a squarefree denominator

    D_deflated = deflate(D)
    D_squarefree = simpleSquarefree(D)
    n = D_deflated.degree - 1
    m = D_squarefree.degree - 1

    symbolsList = []
    B_coefficients = []
    B_exponents = []
    for i in range(n+1):
        symbol = SymbolSet("b" + str(i))
        symbolsList.append(symbol)
        B_coefficients.append(Coefficient(1,symbol))
        B_exponents.append(i)
    B = PolynomialExpression(B_coefficients, B_exponents)

    C_coefficients = []
    C_exponents = []
    for j in range(m+1):
        symbol = SymbolSet("c" + str(j))
        symbolsList.append(symbol)
        C_coefficients.append(Coefficient(1,symbol))
        C_exponents.append(j)
    C = PolynomialExpression(C_coefficients, C_exponents)

    H = A - B.getDerivative() * D_squarefree + B * D_squarefree * D_deflated.getDerivative() / D_deflated - C * D_deflated

    M = SymbolicMatrix(rowCount=H.degree + 1, columnCount=H.degree + 1)
    X = [0] * len(symbolsList)
    for k, coeff in enumerate(H.getCoefficientList()):
        matrixRow = [0] * len(symbolsList)
        for symbol, value in coeff.getTerms().items():
            if symbol in symbolsList: # This is failing because symbol has mutated
                i = symbolsList.index(symbol)
                matrixRow[i] = value
            else:
                X[k] = -1 * value
        M[k] = matrixRow

    coefficientValues = M.solveToList(SymbolicMatrix(X).transpose())
    B_coefficientValues = coefficientValues[:n+1]
    C_coefficientValues = coefficientValues[n+1:]

    g = PolynomialExpression(0)
    for i in range(n+1):
        g += PolynomialExpression(B_coefficientValues[i],i)
    g /= D_deflated
    
    h = PolynomialExpression(0)
    for j in range(m+1):
        h += PolynomialExpression(C_coefficientValues[j],j)
    h /= D_squarefree

    return [g.simplify(),h.simplify()]

# Rothstein-Trager algorithm
def IntRationalLogPart_Rothstein(A, D):
    # Given a field K of characteristic 0
    # Given A, D are elements of K[x]
    # Given degree of A is less than degree of B
    # Given D is nonzero, squarefree, and coprime with A
    # Return the integral of A/D dx in a log form
    
    if not(isinstance(A, PolynomialExpression) and isinstance(D, PolynomialExpression)):
        raise Exception("input A and D must be PolynomialExpressions")

    t = Coefficient(1, "t")
    R = resultant(D, A - t * D.getDerivative())
    
    #Note: the next step requires an algorithm for factoring R. I don't have one readily available yet, so have left this algorithm unfinished

# Lazard-Rioboo-Trager algorithm
def IntRationalLogPart(A, D):
    # Given a field K of characteristic 0
    # Given A, D are elements of K[x]
    # Given degree of A is less than degree of B
    # Given D is nonzero, squarefree, and coprime with A
    # Return the integral of A/D dx in a log form

    if not(isinstance(A, PolynomialExpression) and isinstance(D, PolynomialExpression)):
        raise Exception("input A and D must be PolynomialExpressions")

    t = Coefficient(1, "t")
    R = SubResultant(D, A - t * D.getDerivative())
    R_list = R[1:]
    for i in range(len(R_list)):
        print("R[",i,"] =",R_list[i])
    R = R[0].convertToPolynomial("t")
    # for e in R:
    #     print(e)

    print()
    print("R = ", R)
    print()
    c_Q = Squarefree(R, separateConstant=True)
    c = c_Q[0]
    print()
    Q = c_Q[1]
    print("c = ",c)
    for i in range(len(Q)):
        print("Q[",i,"] =",Q[i])
    print()
    S = []

    for i in range(len(Q)):
        if Q[i].degree == 0:
            S.append(PolynomialExpression(0))
        else:
            if i + 1 == D.degree:
                S.append(D)
            else:
                for m in range(i, len(Q)):
                    if R_list[m+1].degree == i + 1:
                        S.append(R_list[m+1])
                        break
                else:
                    raise Exception("something didn't work")

                print("i =",i)
                print(S[i])
                print(S[i].lc)
                print(S[i].lc.convertToPolynomial("t"))
                A_list = Squarefree(S[i].lc.convertToPolynomial("t"))
                for k in range(len(A_list)):
                    print("A[",k,"] =",A_list[k])
                print(len(A_list))
                for j in range(len(A_list)):
                    print("A[",j,"] =",A_list[j])
                    print("Q[",i,"] =",Q[i])
                    print("gcd =",gcd(A_list[j], Q[i]))
                    S[i] /= gcd(A_list[j], Q[i]) ** (j + 1)
    
    print()
    for element in S:
        print(element)

    print()
    for i in range(len(Q)):
        if Q[i].degree > 0:
            print("root =",Q[i].getRoots())

    for i in range(len(S)):
        pass





# # Example 1.2
# A = PolynomialExpression([3,1,1,5],[3,2,1,0])
# B = PolynomialExpression([5,-3,1],[2,1,0])

# # PolyDivide test
# for result in PolyDivide(A,B):
#     print(result)

# # PolyPseudoDivide test
# for result in PolyPseudoDivide(A,B):
#     print(result)


# # Example 1.3 (Euclidian)
# A = PolynomialExpression([1,-2,-6,12,15],[4,3,2,1,0])
# B = PolynomialExpression([1,1,-4,-4],[3,2,1,0])
# C = PolynomialExpression([1,-1],[2,0])

# # Euclidian test
# print(Euclidian(A,B))

# # Half Extended Euclidian test
# for result in HalfExtendedEuclidian(A,B):
#     print(result)

# # Extended Euclidian test
# for result in ExtendedEuclidian(A,B):
#     print(result)

# # Half Extended Euclidian test - Diophantine version
# print(HalfExtendedEuclidian(A,B,C))

# # Extended Euclidian test - Diophantine version
# for result in ExtendedEuclidian(A,B,C):
#     print(result)


# # Example 1.3 (Partial Fraction Decomposition)
# A = PolynomialExpression([1,3],[2,1])
# B = PolynomialExpression([1,-1,-1,1],[3,2,1,0])
# d1 = PolynomialExpression([1,1],[1,0])
# d2 = PolynomialExpression([1,-2,1],[2,1,0])
# d2_complete = PolynomialExpression([1,-1],[1,0])

# # Partial Fraction Decomposition test
# for result in PartialFraction(A,[d1,d2]):
#     print(result)

# # Full Partial Fraction Decomposition test
# for result in PartialFraction(A,[d1,d2_complete], [1,2]):
#     print(result)


# # Example 1.4 Resultants (Sylvester Matrix)
# A = PolynomialExpression([Coefficient(3,"t"),-1 * (Coefficient(1,"t") ** 3) - 4],[2,0])
# B = PolynomialExpression([1,Coefficient(1,"t") ** 3,-9],[2,1,0])

# # M = createSylvesterMatrix(A, B)
# # print(M)

# # R = resultant(A, B)
# # print(R)

# for result in SubResultant(A, B):
#     print(result)

# # Example 1.4 Subresultants
# A = PolynomialExpression([1,1],[2,0])
# B = PolynomialExpression([1,-1],[2,0])

# M = createSylvesterMatrix(A, B)
# print(M)

# _1M = SylvesterSubmatrix(A, B, 1)
# print()
# print(_1M)

# _1M0 = SylvesterSubmatrix(A, B, 1, 0)
# print()
# print(_1M0)

# _1M1 = SylvesterSubmatrix(A, B, 1, 1)
# print()
# print(_1M1)

# print()
# for result in SubResultant(A, B):
#     print(result)


# # Example 1.7 Squarefree Factorization
# A = PolynomialExpression([1,6,12,8],[8,6,4,2])

# for result in Squarefree_Musser(A):
#     print(result)

# for result in Squarefree(A):
#     print(result)


# # Example 2.2 Hermite Reduction, Horowitz-Ostrogradsky Algorithm
# A = PolynomialExpression([1,-24,-4,8,-8],[7,4,2,1,0])
# B = PolynomialExpression([1,6,12,8],[8,6,4,2])

# for result in HermiteReduce_original(A, B):
#     print(result)

# print()
# for result in HermiteReduce_quadratic(A, B):
#     print(result)

# print()
# for result in HermiteReduce(A, B):
#     print(result)

# print()
# for result in HorowitzOstrogradsky(A, B):
#     print(result)

# Example 2.4 Rothstein-Traget Algorithm
A = PolynomialExpression([1,-3,6],[4,2,0])
D = PolynomialExpression([1,-5,5,4],[6,4,2,0])

# IntRationalLogPart_Rothstein(A, D)

results = IntRationalLogPart(A, D)


# C6N = Coefficient([109956196, 213813584072704, 446704002662400, 367657615360000, 10367298480, 125305183360, 5240557181440, 49544735994880], [Symbol(), Symbol("t",10), Symbol("t",12), Symbol("t",14), Symbol("t",2), Symbol("t",4), Symbol("t",6), Symbol("t",8)])
# C6_Target = Coefficient([2930944, 2198208, 549552, 45796], [Symbol("t",6), Symbol("t",4), Symbol("t",2), Symbol()])
# C6D = Coefficient([2401, -255192, 5683216, 58329600, 125440000],[Symbol(), Symbol("t",2), Symbol("t",4), Symbol("t",6), Symbol("t",8)])

# number = 3
# Big = C6N.evaluate(number)
# Target = C6_Target.evaluate(number)
# print(Big)
# print(Target)
# print(Big/Target)

# desired_Divisor = C6N / C6_Target
# desired_Divisor.simplify()
# print(desired_Divisor)

# number = 2
# numeratorValue = C6N.evaluate(number)
# print(numeratorValue)
# denominatorValue = C6D.evaluate(number)
# print(denominatorValue)

# print(numeratorValue / denominatorValue)


# print(C6N // C6D)

# R6 = C6N/C6D
# print(R6)
# R6.simplify()
# print(R6)

# C41 = Coefficient([49,-8484, 477680, -8030400, -40320000],[Symbol(), Symbol("t",2), Symbol("t",4), Symbol("t",6), Symbol("t",8)])
# C42 = Coefficient([112,-19392, 1091840, -18355200, -92160000],[Symbol(), Symbol("t",2), Symbol("t",4), Symbol("t",6), Symbol("t",8)])
# C4D = Coefficient([1,-120,3600],[Symbol(), Symbol("t",2), Symbol("t",4)])
# R4 = PolynomialExpression([C41,C42],[2,0])
# R4 /= C4D
# R4.simplify()
# print(R4)
# C41 = Coefficient([-11200, -2604, 49],[Symbol("t",4), Symbol("t",2), Symbol()])
# C42 = Coefficient([25600, 5952, -112],[Symbol("t",4), Symbol("t",2), Symbol()])
# R4 = PolynomialExpression([C41,C42],[2,0])

# C51 = Coefficient([-119840, -59920, -7490], [Symbol("t",5), Symbol("t",3), Symbol("t",1)])
# C52 = Coefficient([-23968, -11984, -1498], [Symbol("t",4), Symbol("t",2), Symbol()])
# R5 = PolynomialExpression([C51, C52],[1,0])
# print(R5)
# print()
# print()
# print("R4 = " + str(R4))
# print("R4 = " + str(results[5]))
# print("R5 = " + str(R5))
# print("R5 = " + str(results[6]))

# print()
# print()
# Q_R = PolyPseudoDivide(R4, R5)
# Q = Q_R[0]
# R = Q_R[1]
# print(Q)
# print(R)

# print()
# C6D = R4.lc
# R6 = R / C6D
# R6.simplify()
# print(R6)
# print(results[7])
# R_coeff = R.terms[0]
# R = R_coeff.convertToPolynomial("t")
# print(R)
# factorization = Squarefree(R)
# for factor in factorization:
#     print(factor)
# C6_Target = Coefficient([2930944, 2198208, 549552, 45796], [Symbol("t",6), Symbol("t",4), Symbol("t",2), Symbol()])
# Beta = Coefficient([2401, -255192, 5683216, 58329600, 125440000], [Symbol(), Symbol("t",2), Symbol("t",4), Symbol("t",6), Symbol("t",8)])
# print(C6_Target)
# print(Beta)
# target = C6_Target * Beta
# print(target)
# test = target // Beta # TODO: this division is exact. Figure out how to get simplify to work for cleaning it up
# # test.simplify()
# print(test)



# Coeff = C41/C4D
# print(Coeff)
# Coeff.simplify()
# print(Coeff)


# C21 = Coefficient([-60,1],[Symbol("t",2), Symbol()])
# C22 = Coefficient(2,Symbol("t"))
# C23 = Coefficient([120,-3],[Symbol("t",2), Symbol()])
# C24 = Coefficient(26,Symbol("t"))
# C25 = Coefficient([792,-16],[Symbol("t",2), Symbol()])

# R2 = PolynomialExpression([C21,C22,C23,C24,C25],[4,3,2,1,0])
# print(R2)

# C31 = Coefficient([800, -14],[Symbol("t",3),Symbol("t",1)])
# C32 = Coefficient([-400, 7],[Symbol("t",2),Symbol()])
# C33 = Coefficient([-2440, 32],[Symbol("t",3),Symbol("t",1)])
# C34 = Coefficient([792, -16],[Symbol("t",2),Symbol()])

# R3 = PolynomialExpression([C31,C32,C33,C34],[3,2,1,0])
# print(R3)

# R2_eval = R2.evaluate(7).evaluate(3)
# R3_eval = R3.evaluate(7).evaluate(3)
# basic_Division = R2_eval / R3_eval
# print("---------------------")
# print(basic_Division)

# Q_R = PolyPseudoDivide(R2, R3)
# R = Q_R[1]
# Q = Q_R[0]

# R_eval = R.evaluate(7).evaluate(3)
# Q_eval = Q.evaluate(7).evaluate(3)
# print(R)
# print("---------------------")
# print(Q_eval / R3_eval)
# print(R_eval)
# print("---------------------")
# print(Q_eval / R3_eval + R_eval)
# print("---------------------")

# evaluateX = Q.evaluate(7)
# print(evaluateX)
# evaluateT = evaluateX.evaluate(3)
# print(evaluateT)

# print(Q/R3 + R)

# BetaC = Coefficient([6,-720,21600],[Symbol(), Symbol("t",2), Symbol("t",4)])
# Beta = PolynomialExpression(BetaC)
# print(Beta)

# print("----------------")
# # q_r = PolyDivide(R, Beta)
# # print(q_r[0])
# # print(q_r[1])
# print(R / BetaC)



# coefficients = [1,-24,-4,8,-8]
# exponents = [7,4,2,1,0]
# A = PolynomialExpression(coefficients, exponents)

# coefficients = [1,6,12,8]
# exponents = [8,6,4,2]
# D = PolynomialExpression(coefficients, exponents)



# results = HermiteReduce(A, D)
# print("---------------")
# print("---------------")
# for result in results:
#     print(result)